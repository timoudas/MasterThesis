library(urca)
library(vars)
library(tseries)
library(seasonal)
library(vars)
library(VARsignR)
library(ggplot2)
library(reshape)


source('data_prep.R')
if(!exists("foo", mode="function")) source("adf.R")



#STATIONARY DATA
model_data <- ts.intersect(
                data[, 'CLIF'],
                data[, 'BNP'],
                data[, 'CPI'],
                data[, 'INT'])

model_data_sub <- window(model_data, start=c(1993,1))
colnames(model_data_sub) <-c("CLIF", "BNP", 'CPI', "INT")

ADF.test(model_data_sub[, 'CLIF']) #STATIONARY
ADF.test(model_data_sub[, 'BNP']) #STATIONARY
ADF.test(model_data_sub[, 'CPI']) #STATIONARY
ADF.test(model_data_sub[, 'INT']) #UNIT ROOT
kpss.test(model_data_sub[, 'INT'])

ADF.test(diff(data[, 'CLIF'])) #STATIONARY FD
ADF.test(diff(data[, 'INT'])) #STATIONARY FD


model_data_r <-ts.intersect(
  model_data_sub[, 'CLIF'],
  model_data_sub[, 'BNP'],
  model_data_sub[, 'CPI'],
  diff(model_data_sub[, 'INT']))


colnames(model_data_r) <-c("CLIF", "BNP", 'CPI', "DINT")
plot(model_data_r)


VARselect(model_data_r, lag.max = 7, type="const")

for(i in 1:7){
  model <- VAR(model_data_r, type = c("const"), p=i ,ic = c("AIC"))
  print(serial.test(model))
}


model <- VAR(model_data_r, type = c("const"), p=4 ,ic = c("AIC"))
roots(model)
AIC(model)
BIC(model)
serial.test(model)
normality.test(model)$jb.mul$JB

fvd <- fevd(model, n.ahead=24)
plot(fvd$CLIF)


vars <- c("BNP", 'CPI', "DINT")
for (i in 1:length(vars)){
  print(vars[i])
  png(filename=sprintf("CLIF_%s_IRF.png", vars[i]))
  plot(irf(model, impulse = 'CLIF', response = vars[i], runs = 1000))
  dev.off()
}

VARmakexy <- function(DATA,lags,c_case){
  
  nobs <- nrow(DATA)
  
  #Y matrix 
  Y <- DATA[(lags+1):nrow(DATA),]
  Y <- DATA[-c(1:lags),]
  
  #X-matrix 
  if (c_case==0){
    X <- NA
    for (jj in 0:(lags-1)){
      X <- rbind(DATA[(jj+1):(nobs-lags+jj),])
    } 
  } else if(c_case==1){ #constant
    X <- NA
    for (jj in 0:(lags-1)){
      X <- rbind(DATA[(jj+1):(nobs-lags+jj),])
    }
    X <- cbind(matrix(1,(nobs-lags),1), X) 
  } else if(c_case==2){ # time trend and constant
    X <- NA
    for (jj in 0:(lags-1)){
      X <- rbind(DATA[(jj+1):(nobs-lags+jj),])
    }
    trend <- c(1:nrow(X))
    X <-cbind(matrix(1,(nobs-lags),1), t(trend))
  }
  A <- (t(X) %*% as.matrix(X)) 
  B <- (as.matrix(t(X)) %*% as.matrix(Y))
  
  Ft <- ginv(A) %*% B
  
  retu <- list(X=X,Y=Y, Ft=Ft)
  return(retu)
}

companionmatrix <- function (x) 
{
  if (!(class(x) == "varest")) {
    stop("\nPlease provide an object of class 'varest', generated by 'VAR()'.\n")
  }
  K <- x$K
  p <- x$p
  A <- unlist(Acoef(x))
  companion <- matrix(0, nrow = K * p, ncol = K * p)
  companion[1:K, 1:(K * p)] <- A
  if (p > 1) {
    j <- 0
    for (i in (K + 1):(K * p)) {
      j <- j + 1
      companion[i, j] <- 1
    }
  }
  return(companion)
}

VARhd <- function(Estimation){
  
  ## make X and Y
  nlag    <- Estimation$p   # number of lags
  DATA    <- Estimation$y   # data
  QQ      <- VARmakexy(DATA,nlag,1)
  
  
  ## Retrieve and initialize variables 
  invA    <- t(chol(as.matrix(summary(Estimation)$covres)))   # inverse of the A matrix
  Fcomp   <- companionmatrix(Estimation)                      # Companion matrix
  
  #det     <- c_case                                           # constant and/or trends
  F1      <- t(QQ$Ft)                                         # make comparable to notes
  eps     <- ginv(invA) %*% t(residuals(Estimation))          # structural errors 
  nvar    <- Estimation$K                                     # number of endogenous variables
  nvarXeq <- nvar * nlag                                      # number of lagged endogenous per equation
  nvar_ex <- 0                                                # number of exogenous (excluding constant and trend)
  Y       <- QQ$Y                                             # left-hand side
  #X       <- QQ$X[,(1+det):(nvarXeq+det)]                    # right-hand side (no exogenous)
  nobs    <- nrow(Y)                                          # number of observations
  
  
  ## Compute historical decompositions
  
  # Contribution of each shock
  invA_big <- matrix(0,nvarXeq,nvar)
  invA_big[1:nvar,] <- invA
  Icomp <- cbind(diag(nvar), matrix(0,nvar,(nlag-1)*nvar))
  HDshock_big <- array(0, dim=c(nlag*nvar,nobs+1,nvar))
  HDshock <- array(0, dim=c(nvar,(nobs+1),nvar))
  
  for (j in 1:nvar){  # for each variable
    eps_big <- matrix(0,nvar,(nobs+1)) # matrix of shocks conformable with companion
    eps_big[j,2:ncol(eps_big)] <- eps[j,]
    for (i in 2:(nobs+1)){
      HDshock_big[,i,j] <- invA_big %*% eps_big[,i] + Fcomp %*% HDshock_big[,(i-1),j]
      HDshock[,i,j] <-  Icomp %*% HDshock_big[,i,j]
    } 
    
  } 
  
  HD.shock <- array(0, dim=c((nobs+nlag),nvar,nvar))   # [nobs x shock x var]
  
  for (i in 1:nvar){
    
    for (j in 1:nvar){
      HD.shock[,j,i] <- c(rep(NA,nlag), HDshock[i,(2:dim(HDshock)[2]),j])
    }
  }
  
  return(HD.shock)
  
}

HD <- VARhd(model)

ex <- HD[,,4]
ex1 <- as.data.frame(ex) # transforming the HD matrix as data frame #
ex2 <- ex1[4:84,1:4] # taking our the first 2 rows as they are N/As #
colnames(ex2) <- c("CLIF", "BNP", "CPI", "INT") # renaming columns #
ex2$Period <- 1:nrow(ex2) # creating an id column #

col_id <- grep("Period", names(ex2)) # setting the new variable as id #
ex3 <- ex2[, c(col_id, (1:ncol(ex2))[-col_id])] # moving id variable to the first column #
molten.ex <- melt(ex3, id = "Period") # melting the data frame #

molten.ex$variable <- factor(molten.ex$variable, levels = c("INT",
                                                            "CPI",
                                                            "BNP",
                                                            "CLIF"))

ggplot(molten.ex, aes(x = Period, y = value, fill = variable)) + 
  geom_bar(stat = "identity", width = 0.6) + 
  guides(fill = guide_legend(reverse = TRUE)) +
  # Making the R plot look more like excel for comparison... 

  theme(rect = element_blank(),
        panel.grid.major.y = element_line(colour = "#DADADA"),
        legend.position  = "bottom",
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        legend.key.size = unit(3, "mm"))

ggplot(molten.ex, aes(x = Period, y = value, fill = variable)) + 
  geom_bar(stat = "identity") + 
  guides(fill = guide_legend(reverse = TRUE))








